package main

import "fmt"

func test() (x int) {
  defer func() {
    x++
  }()
  x = 1
  return
}

func anotherTest() int {
  var x int
  defer func() {
    x++
  }()
  x = 1
  return x
}

func main() {
  fmt.Println(test())
  fmt.Println(anotherTest())
}


/* 
При использовании внутри defer переменных из outer функции
получаем ситуацию равносильную передаче аргументов по указателю,
следовательно в defer вызове получим конечные стейты переменных

Если мы используем привычную конструкция func A() int, а после попытаемся изменить переменную int,
которая была объявлена в рамках scope’а функции, в defer, изменения не затронут возвратное значение функции A(),
потому что int копируется в return-регистр ДО вызова defer

Когда мы определяем возвратные значения как именуемые в сигнатуре функции,
эти аргументы живут ровно до выхода из функции, а значит наши return регистры будут содержать актуальные данные

(x int) - актуальные данные
int - неактуальные данные

что происходит
вызываем функцию test() (x int)
	1. x = 0 (дефолтное значение)
	2. x = 1 (присваиваем значение)
	возвращаем x (но не сразу, тк есть defer)
	вообще, когда мы видим return то функция разворачивает свой стек вызовов
	то есть вызывается функция defer func() { x++ }()
	3. x = 2 (увеличиваем значение)
	и теперь финальный return x = 2
	это первый вывод (вывод 2)
вызываем функцию anotherTest() int
	1. var x int (дефолтное значение) x = 0
	2. x = 1 (присваиваем значение)
	видим return => ра скручиваем стек вызовов
	вызывается функция defer func() { x++ }()
	3. x = 1 + 1 = 2
	4. возвращаем x = 1 (возвратное значение не меняется)
	тк (мы как бы уже вернули это значение, до вызова defer)
*/