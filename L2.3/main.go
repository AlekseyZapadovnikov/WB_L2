package main

import (
	"fmt"
	"os"
)

// вот тут мы возвращаем не nil pointer, а интерфейс error, внутри которого лежит nil pointer как динамический тип
func Foo() error {
	var err *os.PathError = nil
	return err
}

func main() {
	err := Foo()
	fmt.Println(err)
	fmt.Println(err == nil) // тут false, потому что err - не nil, а интерфейс, внутри которого лежит nil pointer

	// чтобы было тру, нам надо сделать так
	fmt.Printf("%v\n", err) // %v покажет нам внутренности интерфейса
}

/*
нужно сказать про внутреннее устройство интерфейсов в го
вот я просто писал конспект себе, можно я просто его скину сюда, а Вы, если захотите почитаете это


ИНТЕРФЕЙСЫ
переменная типа интерфейс содержит в себе 2 типа
статический - это тип самой переменной (то есть тип interface)
a := interface{}
у a тип интерфейс
и динамический тип - это тип переменной, которая реализовывает этот интерфейс
(пояснение)

ПОДКАПОТОМ == УСТРОЙСТВО
под капотом интерфейс это структура iface
type iface struct {
    tab  *itab           // информация об интерфейсе
    data unsafe.Pointer // хранимые данные
}
, которая в себе хранит 2 поля
tab (указатель на  itab)
data - это unsafe.Pointer
// itab содержит тип интерфейса и информацию о хранимом типе
type itab struct {
  inter *interfacetype // метаданные интерфейса
  _type *_type         // Go-шный тип хранимого интерфейсом значения
  hash  uint32
  _     [4]byte
  fun   [1]uintptr // список методов типа _type, удовлетворяющих интерфейсу
}
если тебе не понятно что это за ху*ня, давай вместе разбираться)

fun - это массив поинтеров из 1 элемента, ясен красен ничего не понятно

так ну смтрте
inter *interfacetype — это метаданные (информация о сигнатурах метода их имена и тд, крч информация про методы интерфейса)
_type *_type — это тот самый динамический тип, о котором я говорил в начале (это тип переменной, которая в рантайме передалась этому интерфейсу)
hash  uint32  - это хэш динамического типа, чтобы быстро делать type switch и type assert
type switch — это конструкция, которая позволяет определить тип переменной, содержащейся в интерфейсе
type assert - это конструкция вида, s, ok := x.(string) (мы пытаемся привести значение интерфейса X к типу стринг)
_ [4]byte — это поле нужно для выравнивания структуры в памяти
fun   [1]uintptr — это по ФАКТУ указатель на голову массива указателей на функции в нашем динамическом типе ну вот есть у нас какой-то интерфейс и структура, которая реализует интерфейс
и когда мы вызываем метод у интерфейса, в рантайме интерфейс смотрит "а какая у меня там реализация этого метода?"  он мапит этот свой метод, на метод из массива на который указывает fun и вызывает этот метод
(можно пояснить)

почему fun — это массив из 1 элемента?
крч, этот приём позволяет выделить память под массив поинтеров на реальные функции последовательно после структуры (используя одну аллокацию) крч это нужно чтобы этот массив *fun[0] лежал после нашей структуры последовательно, а не где-то непонятно где
— —
в пустом интерфейсе у нас нет itab, есть только unsafe.Pointer
— —
zeroValue = nil

ресурсы:
видео от Otus о интерфейсах (https://youtu.be/nOlkEqftxWg?si=zljDQ2EXvWZumkEt)
*/
